from machine import UART
from machine import Timer
import time

uart = UART(1, baudrate=115200, rx=22, tx=23, timeout=10)
dist1, dist2, dist3, moyenne, error, count = 0, 0, 0, 0, 0, 0
max_error, max_marge, timer_period_ms = 2, 10, 1000

def send_command(cmd):
    uart.write(cmd)

CMD_LOW_POWER_ON = b'\x5A\x06\x35\x01\x00\x96'
CMD_LOW_POWER_OFF = b'\x5A\x06\x35\x00\x00\x96'
CMD_SAVE = b'\x5A\x04\x11\x6F'

def get_distance():
    while uart.any() > 9:
        uart.read(uart.any()) 
    
    time.sleep_ms(10)
    if uart.any() > 0:
        data = uart.read()
        
        header_idx = data.rfind(b'\x59\x59')
        if header_idx != -1 and len(data) >= header_idx + 4:
            dist_low = data[header_idx + 2]
            dist_high = data[header_idx + 3]
            distance = dist_low + (dist_high << 8)
            return distance
    return None

def get_data(timer):
    global max_marge, max_error, dist1, dist2, dist3, moyenne, error, count
    mesure = get_distance()
    
    if mesure is not None:
        if 10 < mesure < 1200:
            if abs(mesure - dist1) <= max_marge or error >= max_error:
                dist3 = dist2
                dist2 = dist1
                dist1 = mesure
                moyenne = int((dist1 + dist2 + dist3) / 3)
                error = 0
            else:
                error += 1
            
            count += 1
            print(f"Distance n°{count}: {dist1} cm\nMoyenne des 3 dernières valeurs: {moyenne} cm\nErreur: {error}\n")
        else:
            count += 1
            print(f"Distance n°{count}: --- Hors limite ---\n")
            
        if error >= max_error:
            print(f"\n--- Plus de {max_error} erreurs de suite, ajustement... ---\n\n")

timer_sensor = Timer(1)
start = time.ticks_ms
timer_sensor.init(mode=Timer.PERIODIC, period=timer_period_ms, callback=get_data)

send_command(CMD_LOW_POWER_ON)
send_command(CMD_SAVE)

while True:
    pass
