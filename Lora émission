from machine import UART, Pin
import time

class LoRaE32:
    def __init__(self, model, uart, aux_pin=None, m0_pin=None, m1_pin=None):
        self.uart = uart
        self.aux = Pin(aux_pin, Pin.IN) if aux_pin is not None else None
        self.m0 = Pin(m0_pin, Pin.OUT) if m0_pin is not None else None
        self.m1 = Pin(m1_pin, Pin.OUT) if m1_pin is not None else None
        self.model = model
        self.config = {
            'HEAD': 0xC0,
            'ADDR_H': 0x00,
            'ADDR_L': 0x00,
            'CHANNEL': 23,
            'OPTION': 0xC0  # Puissance max, mode fixe (point à point)
        }
    def recv_data(self, timeout_ms=100):
        if self.aux and not self.aux.value():
            return None  # Module occupé (TX/RX en cours)
    
        start = time.ticks_ms()
        while not self.uart.any():
            if time.ticks_diff(time.ticks_ms(), start) > timeout_ms:
                return None
    
        packet = self.uart.read(2 + self.uart.any())  # 2 octets addr + data
        if len(packet) < 2:
            return None
    
        addr_h, addr_l = packet[0], packet[1]
        data = packet[2:]
        return (addr_h, addr_l, data)


    def _set_mode(self, mode):
        # Mode = 0 signifie M0=0, M1=0 -> mode normal
        if self.m0 and self.m1:
            self.m0.value(mode & 1)
            self.m1.value((mode >> 1) & 1)
        if self.aux:
            # Attendre que le module soit prêt via pin AUX
            while not self.aux.value():
                time.sleep_ms(10)

    def begin(self):
        # Passer en mode normal avant toute opération
        self._set_mode(0)
        time.sleep(0.1)
        return 0

    def send_data(self, dest_addr_high, dest_addr_low, data: bytes):
        # Forcer mode normal avant envoi
        self._set_mode(0)
        time.sleep(0.05)
        # Format du paquet : addr_h, addr_l + data bytes
        packet = bytes([dest_addr_high, dest_addr_low]) + data
        self.uart.write(packet)
        if self.aux:
            # attendre fin transmission
            while not self.aux.value():
                time.sleep_ms(10)

    def set_config(self, save=True):
        packet = bytes([
            self.config['HEAD'],
            self.config['ADDR_H'],
            self.config['ADDR_L'],
            self.config['CHANNEL'],
            self.config['OPTION'],
            0x00, 0x00
        ])
        self._set_mode(1)  # mode config
        time.sleep(0.1)
        self.uart.write(packet)
        time.sleep(0.1)
        self._set_mode(0)  # retourne mode normal
        if save:
            save_cmd = bytes([0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
            self.send_command(save_cmd)

    def send_command(self, command):
        self._set_mode(1)
        time.sleep(0.05)
        self.uart.write(command)
        time.sleep(0.1)
        self._set_mode(0)
        if self.uart.any():
            return self.uart.read()
        return None

# Exemple d'utilisation
#uart = UART(2, baudrate=9600, tx=17, rx=16)
uart = UART(2, baudrate=9600, tx=15, rx=5)
lora = LoRaE32('868T20D', uart, aux_pin=27, m0_pin=25, m1_pin=26)
lora.begin()

# Configuration puissance max et fréquence 868 MHz (canal 23)
lora.config['CHANNEL'] = 23

# Puissance emission :
# puissance basse à 10 dBm en mode fixe : 0x80 (0x00 + 0x80 pour mode fixe)
# Puissance moyenne à 14 dBm en mode fixe : 0xA0 (0x20 + 0x80)
# Puissance élevée à 17 dBm en mode fixe : 0xC0 (ce que vous avez, 0x40 + 0x80)
# Puissance maximale à 20 dBm : 0xE0 (0x60 + 0x80)

lora.config['OPTION'] = 0x80
lora.set_config(save=True)

# Envoi simple de données en point à point
dest_addr_high = 0x00
dest_addr_low = 0x01
message = b'bonjour'

print("Début des envois toutes les secondes...")

value = 0
while True:
    # Écoute 500ms max
    recv = lora.recv_data(timeout_ms=500)
    if recv:
        src_h, src_l, data = recv
        print(f"Reçu de {src_h:02X}{src_l:02X}:", data)
        if data:
            print("Valeur reçue:", data[0])
    
    # Envoi
    message = bytes([value])
    lora.send_data(dest_addr_high, dest_addr_low, message)
    print("Envoyé:", value)
    value = (value + 1) % 256
    time.sleep(2)

